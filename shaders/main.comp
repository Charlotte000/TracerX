#version 430 core
#pragma shader_stage(compute)

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

const float INV_PI     = 0.31830988618379067;
const float INV_TWO_PI = 0.15915494309189533;
const float TWO_PI     = 6.28318530717958648;

const float EPS = 0.001;
const float INF = 1000000000;

vec2 Stack[64];
int StackPtr = 0;

#include "common/structs.comp"
#include "common/uniforms.comp"
#include "common/random.comp"
#include "common/transforms.comp"
#include "common/intersection.comp"
#include "common/bsdf.comp"
#include "common/tonemap.comp"

vec4 PathTrace(in Ray ray, out vec3 albedo, out vec3 normal, out float depth)
{
    albedo = normal = vec3(0);
    depth = 0;

    vec3 throughput = vec3(1);
    vec3 radiance = vec3(0);

    bool isSampled = false;
    for (uint bounce = 0; bounce <= MaxBounceCount; bounce++)
    {
        CollisionManifold manifold;
        if (!FindIntersection(ray, bounce == 0 ? Camera.ZNear : EPS, bounce == 0 ? Camera.ZFar : INF, manifold))
        {
            radiance += GetEnvironment(ray) * throughput;
            if (!isSampled)
            {
                albedo = radiance;
                normal = -ray.Direction;
                depth = Camera.ZFar;
            }

            return vec4(radiance, !isSampled && Environment.Transparent ? 0 : 1);
        }

        if (BSDF(ray, throughput, radiance, manifold))
        {
            ray.InvDirection = 1 / ray.Direction;
            if (!isSampled)
            {
                albedo = throughput;
                normal = manifold.Normal;
                depth += manifold.Depth;
            }

            isSampled = true;
        }
        else
        {
            ray.Origin = manifold.Point;
            if (!isSampled)
            {
                depth += manifold.Depth;
            }
        }
    }

    return vec4(radiance, 1);
}

void main()
{
    if (any(lessThan(TexelCoord, FramePosition)) || any(lessThanEqual(FramePosition + FrameSize, TexelCoord)))
    {
        return;
    }

    if (OnlyToneMapping)
    {
        vec4 accumColor = imageLoad(AccumulatorImage, TexelCoord);
        imageStore(ToneMapImage, TexelCoord, ToneMap(accumColor / SampleCount));
        return;
    }

    vec2 coord = (UV - vec2(.5)) * vec2(1, float(Size.y) / Size.x) * 2 * tan(Camera.FOV * .5);
    Ray ray = Ray(Camera.Position, normalize(Camera.Forward + CameraRight * coord.x + Camera.Up * coord.y), vec3(0));
    JitterRay(ray);

    vec3 albedo, normal;
    float depth;
    vec4 accumColor = PathTrace(ray, albedo, normal, depth) + imageLoad(AccumulatorImage, TexelCoord);

    if (SampleCount == 0)
    {
        imageStore(AlbedoImage, TexelCoord, vec4(albedo, 1));
        imageStore(NormalImage, TexelCoord, NormalToColor(normal));
        imageStore(DepthImage, TexelCoord, DepthToColor(depth));
    }

    imageStore(AccumulatorImage, TexelCoord, accumColor);
    imageStore(ToneMapImage, TexelCoord, ToneMap(accumColor / (SampleCount + 1)));
}
