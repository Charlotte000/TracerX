#version 430 core

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

const float INV_PI     = 0.31830988618379067;
const float INV_TWO_PI = 0.15915494309189533;
const float TWO_PI     = 6.28318530717958648;

#include common/structs.comp
#include common/uniforms.comp
#include common/random.comp
#include common/transforms.comp
#include common/intersection.comp

bool CollisionReact(inout Ray ray, inout vec3 throughput, inout vec3 radiance, inout CollisionManifold manifold)
{
    Material material = Materials[manifold.MaterialId];

    if (material.AlbedoTextureId >= 0)
    {
        vec4 texAlbedo = texture(Textures, vec3(manifold.TextureCoordinate, material.AlbedoTextureId));
        material.AlbedoColor *= texAlbedo.rgb;

        // Alpha blend
        if (texAlbedo.a < RandomValue())
        {
            return false;
        }
    }

    if (material.MetalnessTextureId >= 0)
    {
        material.Metalness *= texture(Textures, vec3(manifold.TextureCoordinate, material.MetalnessTextureId)).b;
    }

    if (material.RoughnessTextureId >= 0)
    {
        material.Roughness *= texture(Textures, vec3(manifold.TextureCoordinate, material.RoughnessTextureId)).g;
    }

    material.EmissionColor *= material.EmissionStrength;
    if (material.EmissionTextureId >= 0)
    {
        material.EmissionColor *= texture(Textures, vec3(manifold.TextureCoordinate, material.EmissionTextureId)).rgb;
    }

    if (material.NormalTextureId >= 0)
    {
        vec3 texNormal = texture(Textures, vec3(manifold.TextureCoordinate, material.NormalTextureId)).rgb;
        texNormal.y = 1 - texNormal.y;
        texNormal = normalize(texNormal * 2 - 1);
        manifold.Normal = normalize(manifold.Tangent * texNormal.x + manifold.Bitangent * texNormal.y + manifold.Normal * texNormal.z);
    }

    if (!manifold.IsFrontFace)
    {
        manifold.Normal *= -1;
    }

    vec3 specularDir = reflect(ray.Direction, manifold.Normal);
    vec3 diffuseDir = normalize(RandomVector3() + manifold.Normal);

    if (material.Metalness <= RandomValue() && RandomValue() >= 0.2)
    {
        material.Roughness = 1;
    }

    // Fresnel
    if (material.FresnelStrength > 0.0 &&
        1.0 - pow(dot(manifold.Normal, -ray.Direction), material.FresnelStrength) >= RandomValue())
    {
        ray.Origin = manifold.Point;
        ray.Direction = specularDir;

        radiance += material.EmissionColor * throughput;
        throughput *= material.FresnelColor;
        return true;
    }

    // Density
    if (material.Density > 0.0)
    {
        float depth = -log(RandomValue()) / material.Density;
        if (manifold.IsFrontFace || depth >= manifold.Depth)
        {
            return false;
        }

        ray.Origin += ray.Direction * depth;
        ray.Direction = RandomVector3();

        radiance += material.EmissionColor * throughput;
        throughput *= material.AlbedoColor;
        return true;
    }

    // Refract
    if (material.IOR > 0.0)
    {
        vec3 refractedDir = refract(ray.Direction, manifold.Normal, manifold.IsFrontFace ? 1.0 / material.IOR : material.IOR);
        if (refractedDir == vec3(0))
        {
            refractedDir = specularDir;
        }

        ray.Origin = manifold.Point;
        ray.Direction = refractedDir;

        radiance += material.EmissionColor * throughput;
        throughput *= material.AlbedoColor;
        return true;
    }

    // Scatter
    ray.Origin = manifold.Point;
    ray.Direction = Slerp(specularDir, diffuseDir, material.Roughness);

    radiance += material.EmissionColor * throughput;
    throughput *= material.AlbedoColor;
    return true;
}

vec4 PathTrace(in Ray ray, out vec3 albedo, out vec3 normal, out float depth)
{
    albedo = normal = vec3(0);
    depth = 0;

    vec3 throughput = vec3(1);
    vec3 radiance = vec3(0);

    bool isFirstHit = true;
    uint bounce = 0;
    while (bounce <= MaxBounceCount)
    {
        CollisionManifold manifold;
        if (!FindIntersection(ray, isFirstHit ? MinRenderDistance : 0, manifold))
        {
            radiance += GetEnvironment(ray) * throughput;
            if (bounce == 0)
            {
                albedo = radiance;
                normal = -ray.Direction;
                depth = MaxRenderDistance;
            }

            return vec4(radiance, Environment.Transparent ? 0 : 1);
        }

        if (CollisionReact(ray, throughput, radiance, manifold))
        {
            ray.InvDirection = 1 / ray.Direction;
            if (bounce == 0)
            {
                albedo = throughput;
                normal = manifold.Normal;
                depth += manifold.Depth;
            }

            bounce++;
        }
        else
        {
            ray.Origin = manifold.Point;
            if (bounce == 0)
            {
                depth += manifold.Depth;
            }
        }

        isFirstHit = false;
    }

    return vec4(radiance, 1);
}

void main()
{
    if (any(lessThan(TexelCoord, UVlow)) || any(lessThanEqual(UVup, TexelCoord)))
    {
        return;
    }

    if (OnlyToneMapping)
    {
        vec4 accumColor = imageLoad(AccumulatorImage, TexelCoord);
        imageStore(ToneMapImage, TexelCoord, ToneMap(accumColor / (SampleCount), Gamma));
        return;
    }

    vec2 coord = (UV - vec2(.5)) * vec2(1, float(Size.y) / Size.x) * 2 * tan(Camera.FOV / 2);
    Ray ray = Ray(Camera.Position, normalize(Camera.Forward + CameraRight * coord.x + Camera.Up * coord.y), vec3(0));
    JitterRay(ray);

    vec3 albedo, normal;
    float depth;
    vec4 accumColor = PathTrace(ray, albedo, normal, depth) + imageLoad(AccumulatorImage, TexelCoord);

    imageStore(AccumulatorImage, TexelCoord, accumColor);
    imageStore(AlbedoImage, TexelCoord, ToneMap(vec4(albedo, 1), Gamma));
    imageStore(NormalImage, TexelCoord, NormalToColor(normal));
    imageStore(DepthImage, TexelCoord, DepthToColor(depth));
    imageStore(ToneMapImage, TexelCoord, ToneMap(accumColor / (SampleCount + 1), Gamma));
}
