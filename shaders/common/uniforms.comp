layout(rgba32f, binding=0)           uniform image2D AccumulatorImage;
layout(rgba32f, binding=1) writeonly uniform image2D AlbedoImage;
layout(rgba32f, binding=2) writeonly uniform image2D NormalImage;
layout(r32f,    binding=3) writeonly uniform image2D DepthImage;
layout(rgba32f, binding=4) writeonly uniform image2D ToneMapImage;

layout(binding=0) uniform sampler2D EnvironmentTexture;
layout(binding=1) uniform sampler2DArray Textures;

layout(std430, binding=0) readonly buffer VertexSSBO
{
    Vertex Vertices[];
};

layout(std430, binding=1) readonly buffer TriangleSSBO
{
    Triangle Triangles[];
};

layout(std430, binding=2) readonly buffer MeshSSBO
{
    Mesh Meshes[];
};

layout(std430, binding=3) readonly buffer MeshInstanceSSBO
{
    MeshInstance MeshInstances[];
};

layout(std430, binding=4) readonly buffer MaterialSSBO
{
    Material Materials[];
};

layout(std430, binding=5) readonly buffer BvhSSBO
{
    Node BVH[];
};

layout(std140, binding=0) uniform CameraUBO
{
    Cam Camera;
};

layout(std140, binding=1) uniform EnvironmentUBO
{
    Env Environment;
};

layout(std140, binding=2) uniform ParamsUBO
{
    ivec2 FramePosition;
    ivec2 FrameSize;
    uint SampleCount;
    uint MaxBounceCount;
    float MinRenderDistance;
    float MaxRenderDistance;
    float Gamma;
    bool OnlyToneMapping;
    uint ToneMapMode;
};

ivec2 Size = imageSize(AccumulatorImage);
ivec2 TexelCoord = ivec2(gl_GlobalInvocationID.xy);
vec2 UV = vec2(TexelCoord) / Size;
vec3 CameraRight = cross(Camera.Forward, Camera.Up);

vec3 GetEnvironment(in Ray ray)
{
    vec3 direction = Environment.Rotation * ray.Direction;
    float u = atan(direction.z, direction.x) * INV_TWO_PI + 0.5;
    float v = acos(direction.y) * INV_PI;
    return texture(EnvironmentTexture, vec2(u, v)).rgb * Environment.Intensity;
}

Material GetMaterial(inout CollisionManifold manifold, out float alpha)
{
    alpha = 1;
    Material material = Materials[manifold.MaterialId];

    if (material.AlbedoTextureId >= 0)
    {
        vec4 texAlbedo = texture(Textures, vec3(manifold.TextureCoordinate, material.AlbedoTextureId));
        material.AlbedoColor *= texAlbedo.rgb;
        alpha = texAlbedo.a;
    }

    if (material.MetalnessTextureId >= 0)
    {
        material.Metalness *= texture(Textures, vec3(manifold.TextureCoordinate, material.MetalnessTextureId)).b;
    }

    if (material.RoughnessTextureId >= 0)
    {
        material.Roughness *= texture(Textures, vec3(manifold.TextureCoordinate, material.RoughnessTextureId)).g;
    }

    material.EmissionColor *= material.EmissionStrength;
    if (material.EmissionTextureId >= 0)
    {
        material.EmissionColor *= texture(Textures, vec3(manifold.TextureCoordinate, material.EmissionTextureId)).rgb;
    }

    if (material.NormalTextureId >= 0)
    {
        vec3 texNormal = texture(Textures, vec3(manifold.TextureCoordinate, material.NormalTextureId)).rgb;
        texNormal.y = 1 - texNormal.y;
        texNormal = normalize(texNormal * 2 - 1);
        manifold.Normal = normalize(manifold.Tangent * texNormal.x + manifold.Bitangent * texNormal.y + manifold.Normal * texNormal.z);
    }

    if (!manifold.IsFrontFace)
    {
        manifold.Normal *= -1;
    }

    return material;
}
