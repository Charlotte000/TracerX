// https://github.com/brandonpelfrey/Fast-BVH/blob/master/include/FastBVH/Traverser.h#L61
#define Traverse(BVH, NODE_OFFSET, PRIMITIVE_OFFSET, LEAF) \
{ \
    /* Bounding box min-t/max-t for left/right children at some point in the tree */ \
    vec4 bbhits; \
    ivec2 range; \
     \
    int stackOffset = StackPtr; \
     \
    /* "Push" on the root node to the working set */ \
    Stack[++StackPtr] = vec2(NODE_OFFSET, -1); \
     \
    while (StackPtr > stackOffset) \
    { \
        /* Pop off the next node to work on. */ \
        int ni = int(Stack[StackPtr].x); \
        float near = Stack[StackPtr--].y; \
         \
        Node node = BVH[ni]; \
         \
        /* If this node is further than the closest found intersection, continue */ \
        if (near > manifold.Depth) continue; \
         \
        /* Is leaf -> Intersect */ \
        if (node.RightOffset == 0) \
        { \
            int o = node.Start + PRIMITIVE_OFFSET; \
            int oMax = o + node.PrimitiveCount; \
            for (; o < oMax; ++o) \
            { \
                LEAF; \
            } \
        } \
        else /* Not a leaf */ \
        { \
            Node c0 = BVH[ni + 1]; \
            Node c1 = BVH[ni + node.RightOffset]; \
             \
            bool hitc0 = AABBIntersection(ray, c0.BboxMin.xyz, c0.BboxMax.xyz, bbhits.x, bbhits.y); \
            bool hitc1 = AABBIntersection(ray, c1.BboxMin.xyz, c1.BboxMax.xyz, bbhits.z, bbhits.w); \
             \
            /* Did we hit both nodes? */ \
            if (hitc0 && hitc1) \
            { \
                /* We assume that the left child is a closer hit... */ \
                range = ivec2(ni + 1, ni + node.RightOffset); \
                 \
                /* ... If the right child was actually closer, swap the relavent values. */ \
                if (bbhits.z < bbhits.x) \
                { \
                    bbhits.xz = bbhits.zx; \
                    bbhits.yw = bbhits.wy; \
                    range.xy = range.yx; \
                } \
                 \
                /* It's possible that the nearest object is still in the other side, but */ \
                /* we'll check the further-awar node later... */ \
                 \
                /* Push the farther first */ \
                Stack[++StackPtr] = vec2(range.y, bbhits.z); \
                 \
                /* And now the closer (with overlap test) */ \
                Stack[++StackPtr] = vec2(range.x, bbhits.x); \
            } \
            else if (hitc0) \
            { \
                Stack[++StackPtr] = vec2(ni + 1, bbhits.x); \
            } \
            else if (hitc1) \
            { \
                Stack[++StackPtr] = vec2(ni + node.RightOffset, bbhits.z); \
            } \
        } \
    } \
}

bool TriangleIntersection(in Ray ray, in Vertex v1, in Vertex v2, in Vertex v3, in int materialId, in float minDistance, in float maxDistance, inout CollisionManifold manifold)
{
    vec3 edge12 = v2.PositionU.xyz - v1.PositionU.xyz;
    vec3 edge13 = v3.PositionU.xyz - v1.PositionU.xyz;
    vec3 normal = cross(edge12, edge13);
    float det = -dot(ray.Direction, normal);

    if (abs(det) <= length(normal) * EPS)
    {
        return false;
    }

    vec3 ao = ray.Origin - v1.PositionU.xyz;
    vec3 dao = cross(ao, ray.Direction);

    float invDet = 1 / det;

    float dst = dot(ao, normal) * invDet;
    float u = dot(edge13, dao) * invDet;
    float v = -dot(edge12, dao) * invDet;
    float w = 1 - u - v;

    if (u < 0 || v < 0 || w < 0 || dst <= minDistance || dst >= maxDistance)
    {
        return false;
    }

    vec2 uv1 = vec2(v1.PositionU.w, v1.NormalV.w);
    vec2 uv2 = vec2(v2.PositionU.w, v2.NormalV.w);
    vec2 uv3 = vec2(v3.PositionU.w, v3.NormalV.w);

    vec2 uv = uv1 * w + uv2 * u + uv3 * v;
    if (!AlphaBlend(materialId, uv))
    {
        return false;
    }

    vec2 edgeUV12 = uv2 - uv1;
    vec2 edgeUV13 = uv3 - uv1;
    float invDetUV = 1 / (edgeUV12.x * edgeUV13.y - edgeUV12.y * edgeUV13.x);

    manifold.Depth = dst;
    manifold.Point = ray.Origin + ray.Direction * dst;
    manifold.TextureCoordinate = uv;
    manifold.Normal = normalize(v1.NormalV.xyz * w + v2.NormalV.xyz * u + v3.NormalV.xyz * v);
    manifold.Tangent = normalize((edge12 * edgeUV13.y - edge13 * edgeUV12.y) * invDetUV);
    manifold.Bitangent = normalize((edge13 * edgeUV12.x - edge12 * edgeUV13.x) * invDetUV);
    manifold.MaterialId = materialId;
    manifold.IsFrontFace = det >= 0;
    return true;
}

bool AABBIntersection(in Ray ray, in vec3 boxMin, in vec3 boxMax, out float tNear, out float tFar)
{
    vec3 tMin = (boxMin - ray.Origin) * ray.InvDirection;
    vec3 tMax = (boxMax - ray.Origin) * ray.InvDirection;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    tNear = max(max(t1.x, t1.y), t1.z);
    tFar = min(min(t2.x, t2.y), t2.z);
    return tNear <= tFar && tFar >= 0;
}

bool MeshInstanceIntersection(in Ray ray, in MeshInstance meshInstance, in float minDistance, in float maxDistance, out CollisionManifold manifold)
{
    const Mesh mesh = Meshes[meshInstance.MeshId];

    vec3 rayOrigin = ray.Origin;
    ray.Origin = Transform(ray.Origin, meshInstance.TransformInv, true);
    ray.Direction = normalize(Transform(ray.Direction, meshInstance.TransformInv, false));
    ray.InvDirection = 1 / ray.Direction;

    float localMinDistance = length(Transform(ray.Direction * minDistance, meshInstance.TransformInv, false));
    float localMaxDistance = length(Transform(ray.Direction * maxDistance, meshInstance.TransformInv, false));
    manifold.Depth = localMaxDistance;

    Traverse(
        BLAS,
        mesh.NodeOffset,
        mesh.TriangleOffset,
        {
            Triangle triangle = Triangles[o];
            Vertex v1 = Vertices[triangle.V1];
            Vertex v2 = Vertices[triangle.V2];
            Vertex v3 = Vertices[triangle.V3];
            TriangleIntersection(ray, v1, v2, v3, meshInstance.MaterialId, localMinDistance, manifold.Depth, manifold);
        }
    );


    if (manifold.Depth < localMaxDistance)
    {
        manifold.Point = Transform(manifold.Point, meshInstance.Transform, true);
        manifold.Depth = length(manifold.Point - rayOrigin);
        manifold.Normal = normalize(Transform(manifold.Normal, meshInstance.Transform, false));
        manifold.Tangent = normalize(Transform(manifold.Tangent, meshInstance.Transform, false));
        manifold.Bitangent = normalize(Transform(manifold.Bitangent, meshInstance.Transform, false));
        return true;
    }

    return false;
}

bool FindIntersection(in Ray ray, in float minDistance, in float maxDistance, out CollisionManifold manifold)
{
    manifold.Depth = maxDistance;

    Traverse(
        TLAS,
        0,
        0,
        {
            MeshInstance meshInstance = MeshInstances[o];
            CollisionManifold current;
            if (MeshInstanceIntersection(ray, meshInstance, minDistance, manifold.Depth, current))
            {
                manifold = current;
            }
        }
    );

    return manifold.Depth < maxDistance;
}
